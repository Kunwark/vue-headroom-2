(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.vueHeadroom = factory());
}(this, (function () { 'use strict';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var __moduleExports = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);
});

var index = createCommonjsModule(function (module) {
var now = __moduleExports
  , root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function() {
  root.requestAnimationFrame = raf
  root.cancelAnimationFrame = caf
}
});

function checkActions(states) {
  var direction = states.currentScrollY >= states.lastScrollY ? 'down' : 'up';
  var distanceScrolled = Math.abs(states.currentScrollY - states.lastScrollY);

  var action = void 0;

  // Begining, at the top and not fixed.
  if (states.currentScrollY <= states.pinStart && states.state !== 'unfixed') {
    action = 'unfix';

    // Still unfixed, scrolling down and passing the header.
  } else if (states.currentScrollY <= states.elemHeight && direction === 'down' && states.state === 'unfixed') {
    action = 'none';

    // Scrolling down and past the header.
    // Unpinned the header.
  } else if (direction === 'down' && ['pinned', 'unfixed'].indexOf(states.state) >= 0 && states.currentScrollY > states.elemHeight + states.pinStart && distanceScrolled > states.downTolerance) {
    action = 'unpin';

    // Now, it's time to up.
    // Pin the header.
  } else if (direction === 'up' && distanceScrolled > states.upTolerance && ['pinned', 'unfixed'].indexOf(states.state) < 0) {
    action = 'pin';

    // Still scrolling up and passing the header.
    // Pin the header regardless of upTolerance.
  } else if (direction === 'up' && states.currentScrollY <= states.elemHeight && ['pinned', 'unfixed'].indexOf(states.state) < 0) {
    action = 'pin';
  } else {
    action = 'none';
  }

  return action;
}

var headroom = {
  template: '\n    <div class="headroom-wrapper" :style="wrapperStyles">\n      <div class="headroom" :style="innerStyle">\n        <slot></slot>\n      </div>\n    </div>\n  ',

  data: function data() {
    return {
      currentScrollY: 0,
      lastScrollY: 0,
      elemHeight: 0,
      state: '',
      translate: 0
    };
  },


  props: {
    disabled: {
      type: Boolean,
      default: false
    },

    upTolerance: {
      type: Number,
      default: 5
    },

    downTolerance: {
      type: Number,
      default: 0
    },

    speed: {
      type: Number,
      default: 250
    },

    easing: {
      type: String,
      default: 'ease-in-out'
    },

    zIndex: {
      type: Number,
      default: 9999
    },

    onPin: Function,
    onUnpin: Function,

    pinStart: {
      type: Number,
      default: 0
    }
  },

  watch: {
    disabled: function disabled(newVal) {
      if (newVal) {
        this.unfix();
        window.removeEventListener('scroll', this._handleScroll);
      }
    }
  },

  mounted: function mounted() {
    this.elemHeight = this.$el.offsetHeight;
    if (!this.disabled) {
      window.addEventListener('scroll', this._handleScroll);
    }
  },


  computed: {
    innerStyle: function innerStyle() {
      return {
        'position': this.isInTop ? 'fixed' : 'relative',
        'top': '0',
        'left': '0',
        'right': '0',
        'z-index': this.isInTop ? this.zIndex : 1,
        'transform': 'translateY(' + this.translate + ')',
        'transition': this.isInTop ? 'all ' + this.speed + 'ms ' + this.easing : null
      };
    },
    wrapperStyles: function wrapperStyles() {
      return {
        height: this.elemHeight ? this.elemHeight + 'px' : null
      };
    },
    isInTop: function isInTop() {
      return this.state === 'pinned' || this.state === 'unpinned';
    }
  },

  methods: {
    _handleScroll: function _handleScroll() {
      index(this.update);
    },
    _getScrollY: function _getScrollY() {
      var top = void 0;
      if (window.pageYOffset !== undefined) {
        top = window.pageYOffset;
      } else if (window.scrollTop !== undefined) {
        top = window.scrollTop;
      } else {
        top = (document.documentElement || document.body.parentNode || document.body).scrollTop;
      }
      return top;
    },
    update: function update() {
      this.currentScrollY = this._getScrollY();

      var action = checkActions(this);

      if (action === 'pin') {
        this.pin();
      } else if (action === 'unpin') {
        this.unpin();
      } else if (action === 'unfix') {
        this.unfix();
      }

      this.lastScrollY = this.currentScrollY;
    },
    pin: function pin() {
      var _this = this;

      if (this.onPin) {
        this.onPin();
      }
      this.translate = 0;
      setTimeout(function () {
        _this.state = 'pinned';
      }, 0);
    },
    unpin: function unpin() {
      var _this2 = this;

      if (this.onUnpin) {
        this.onUnpin();
      }
      this.translate = '-100%';
      setTimeout(function () {
        _this2.state = 'unpinned';
      }, 0);
    },
    unfix: function unfix() {
      this.state = 'unfixed';
    }
  }

};

return headroom;

})));